<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мониторинг</title>
    <link rel="icon" href="/static/images/favicon.ico" type="image/x-icon">

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- <span class="material-icons">home</span> -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#1E40AF',
                        success: '#10B981',
                        danger: '#EF4444'
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-gray-900 text-white min-h-screen p-8">
    {{template "navbar.html" .}}

    <div class="max-w-3xl mx-auto">
        <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center">Мониторинг</h1>

        <div id="quiz-container" class="space-y-8"></div>

        <button onclick="checkAnswers()"
            class="mt-8 w-full py-3 bg-primary hover:bg-secondary text-white font-bold rounded-lg transition duration-300">
            Проверить результат
        </button>

        <div id="result" class="hidden mt-8 p-6 bg-gray-800 rounded-lg text-center">
            <h2 class="text-2xl font-bold mb-4">Ваш результат:</h2>
            <p id="percentage" class="text-4xl text-primary font-mono"></p>
        </div>
    </div>

    <script>
        const quizData = [
            {
                question: "Какое представление отслеживает статистику по слотам репликации в PostgreSQL?",
                options: ["pg_stat_database", "pg_stat_replication_slots", "pg_stat_wal_receiver", "pg_stat_subscription"],
                answer: 1
            },
            {
                question: "Что показывает столбец 'spill_txns' в представлении pg_stat_replication_slots?",
                options: ["Количество активных подключений", "Число транзакций, вытесненных на диск при логическом декодировании", "Количество WAL-файлов", "Число ошибок репликации"],
                answer: 1
            },
            {
                question: "Какой параметр конфигурации отвечает за сбор статистики по таблицам и индексам?",
                options: ["track_activities", "track_counts", "log_temp_files", "track_io_timing"],
                answer: 1
            },
            {
                question: "Какой инструмент позволяет выполнять сложный анализ журналов PostgreSQL?",
                options: ["check_postgres", "Nagios", "pgBadger", "Zabbix"],
                answer: 2
            },
            {
                question: "Для какого процесса используется представление pg_stat_progress_vacuum?",
                options: ["Анализ таблицы", "Создание индекса", "Очистка (VACUUM)", "Копирование данных"],
                answer: 2
            },
            {
                question: "Какой столбец в pg_stat_database указывает на количество строк, удалённых запросами?",
                options: ["tup_deleted", "n_tup_del", "xact_rollback", "deadlocks"],
                answer: 0
            },
            {
                question: "Что означает значение NULL в столбце 'reply_time' у ведомых серверов?",
                options: ["Сервер работает некорректно", "Соединение потеряно или данные ещё не получены", "Ошибка в настройке репликации", "Сервер не зарегистрирован"],
                answer: 1
            },
            {
                question: "Какой параметр необходимо включить, чтобы собирать данные о времени выполнения операций fsync?",
                options: ["track_io_timing", "log_temp_files", "track_counts", "checkpoint_segments"],
                answer: 0
            },
            {
                question: "Какое представление содержит информацию о количестве критических ошибок в базе данных?",
                options: ["pg_stat_database", "pg_stat_database_conflicts", "pg_stat_bgwriter", "pg_stat_archiver"],
                answer: 0
            },
            {
                question: "Какой из следующих вариантов указывает на количество записей, которые были исключены командой COPY из-за условия WHERE?",
                options: ["tuples_processed", "tuples_excluded", "tup_returned", "tup_fetched"],
                answer: 1
            },
            {
                question: "Какой столбец в pg_stat_all_tables отражает оценочное число мёртвых строк в таблице?",
                options: ["n_live_tup", "n_dead_tup", "n_tup_upd", "n_mod_since_analyze"],
                answer: 1
            },
            {
                question: "Какой из перечисленных процессов может быть источником большого количества fsync со стороны клиентских процессов?",
                options: ["Неправильная настройка shared_buffers", "Слишком маленький work_mem", "Высокая степень параллелизма", "Использование SSD вместо HDD"],
                answer: 0
            },
            {
                question: "Какое представление используется для отслеживания хода выполнения команды CLUSTER?",
                options: ["pg_stat_progress_create_index", "pg_stat_progress_vacuum", "pg_stat_progress_cluster", "pg_stat_progress_copy"],
                answer: 2
            },
            {
                question: "Что описывает параметр stats_fetch_consistency при работе с накопительной статистикой?",
                options: ["Время обновления статистики", "Уровень детализации статистики", "Степень согласованности выборки", "Тип собираемых метрик"],
                answer: 2
            },
            {
                question: "Какое представление показывает общую статистику по количеству активных сеансов и их состоянию?",
                options: ["pg_stat_database", "pg_stat_sessions", "pg_stat_user_functions", "pg_stat_progress_copy"],
                answer: 0
            },
            {
                question: "Какой из следующих столбцов отражает объём данных, записанных во временные файлы?",
                options: ["temp_bytes", "temp_files", "deadlocks", "checksum_failures"],
                answer: 0
            },
            {
                question: "Какое представление содержит данные о количестве ошибок, возникших при применении изменений подпиской?",
                options: ["pg_stat_subscription", "pg_stat_subscription_stats", "pg_stat_replication", "pg_stat_wal_receiver"],
                answer: 1
            },
            {
                question: "Какое представление можно использовать для анализа использования буферов в SLRU-кеше?",
                options: ["pg_stat_io", "pg_stat_slru", "pg_stat_bgwriter", "pg_stat_database"],
                answer: 1
            },
            {
                question: "Какой из следующих инструментов позволяет отправлять уведомления в Nagios при появлении важных сообщений в журнале?",
                options: ["pgBadger", "check_postgres", "Zabbix", "OPM"],
                answer: 1
            },
            {
                question: "Какой из следующих параметров влияет на частоту обновления статистики в представлениях?",
                options: ["track_io_timing", "track_activities", "PGSTAT_MIN_INTERVAL", "stats_fetch_consistency"],
                answer: 2
            },
            {
                question: "Какой из следующих столбцов отражает количество «живых» строк, выбранных при сканировании индексов?",
                options: ["tup_returned", "tup_fetched", "idx_tup_read", "idx_tup_fetch"],
                answer: 3
            },
            {
                question: "Какой столбец в pg_stat_database_conflicts считает количество запросов, отменённых из-за взаимоблокировок?",
                options: ["confl_lock", "confl_snapshot", "confl_deadlock", "confl_bufferpin"],
                answer: 2
            },
            {
                question: "Какое поле в pg_stat_wal_receiver показывает последнюю позицию в WAL, уже сброшенную на диск?",
                options: ["received_lsn", "flushed_lsn", "latest_end_lsn", "write_lsn"],
                answer: 1
            },
            {
                question: "Какой параметр отвечает за ограничение длины строки запроса в pg_stat_statements?",
                options: ["track_activity_query_size", "log_min_duration_statement", "statement_timeout", "work_mem"],
                answer: 0
            },
            {
                question: "Какой из следующих столбцов отражает количество запрошенных операций предвыборки, ещё не завершённых?",
                options: ["block_distance", "io_depth", "skip_new", "skip_init"],
                answer: 1
            },
            {
                question: "Какое представление содержит данные о количестве успешных архиваций WAL-файлов?",
                options: ["pg_stat_archiver", "pg_stat_wal", "pg_stat_replication", "pg_stat_bgwriter"],
                answer: 0
            },
            {
                question: "Какой из следующих столбцов отражает время, затраченное на операции расширения отношений?",
                options: ["extend_time", "read_time", "write_time", "fsync_time"],
                answer: 0
            },
            {
                question: "Какое значение принимает состояние 'sync_state' у синхронного ведомого сервера?",
                options: ["async", "potential", "sync", "quorum"],
                answer: 2
            },
            {
                question: "Какой из следующих процессов может вызвать большое количество fsync со стороны клиентских процессов?",
                options: ["Низкое значение checkpoint_segments", "Маленькое значение work_mem", "Неверная настройка shared_buffers", "Высокий уровень параллелизма"],
                answer: 2
            },
            {
                question: "Какой из следующих параметров позволяет гарантировать сохранение данных в постоянном хранилище?",
                options: ["synchronous_commit", "checkpoint_segments", "shared_buffers", "work_mem"],
                answer: 0
            },
            {
                question: "Какой столбец в pg_stat_all_indexes отражает количество элементов индекса, возвращаемых при сканированиях?",
                options: ["idx_tup_fetch", "idx_blks_hit", "idx_blks_read", "idx_tup_read"],
                answer: 3
            },
            {
                question: "Какой из следующих столбцов отражает количество блоков, не выбранных предварительно из-за того, что они уже находились в пуле буферов?",
                options: ["skip_init", "skip_new", "skip_fpw", "skip_rep"],
                answer: 0
            },
            {
                question: "Какой из следующих параметров влияет на частоту создания контрольных точек?",
                options: ["checkpoint_segments", "checkpoint_timeout", "max_wal_size", "min_wal_size"],
                answer: 1
            },
            {
                question: "Какое представление используется для анализа использования буферов фоновым процессом записи?",
                options: ["pg_stat_io", "pg_stat_slru", "pg_stat_bgwriter", "pg_stat_database"],
                answer: 2
            },
            {
                question: "Какой из следующих столбцов отражает количество сеансов, прерванных из-за потери соединения с клиентом?",
                options: ["sessions_abandoned", "sessions_fatal", "sessions_killed", "sessions_total"],
                answer: 0
            },
            {
                question: "Какой из следующих столбцов отражает количество попаданий в кеш при чтении индексов?",
                options: ["idx_blks_hit", "heap_blks_hit", "heap_blks_read", "idx_blks_read"],
                answer: 3
            },
            {
                question: "Какой из следующих столбцов отражает количество ошибок контрольных сумм в страницах данных?",
                options: ["checksum_last_failure", "checksum_failures", "deadlocks", "conflicts"],
                answer: 1
            },
            {
                question: "Какой из следующих столбцов отражает количество блоков, прочитанных при последовательном сканировании таблицы?",
                options: ["heap_blks_read", "heap_blks_hit", "idx_blks_read", "toast_blks_read"],
                answer: 0
            },
            {
                question: "Какой из следующих столбцов отражает количество транзакций, для которых был выполнен откат?",
                options: ["xact_commit", "xact_rollback", "tup_inserted", "tup_updated"],
                answer: 1
            },
            {
                question: "Какой из следующих столбцов отражает количество запросов, отменённых из-за устаревших снимков данных?",
                options: ["confl_lock", "confl_snapshot", "confl_deadlock", "confl_bufferpin"],
                answer: 1
            },
            {
                question: "Какой из следующих столбцов отражает количество блоков, проверенных на наличие в SLRU-кеше?",
                options: ["blks_read", "blks_written", "truncates", "blks_exists"],
                answer: 3
            },
            {
                question: "Какой из следующих столбцов отражает количество операций расширения отношений?",
                options: ["reads", "writes", "extends", "fsyncs"],
                answer: 2
            },
            {
                question: "Какой из следующих столбцов отражает количество грязных буферов, записанных при выполнении контрольной точки?",
                options: ["buffers_clean", "buffers_backend", "buffers_alloc", "buffers_checkpoint"],
                answer: 3
            },
            {
                question: "Какой из следующих столбцов отражает количество блоков, не выбранных предварительно, потому что они должны инициализироваться нулями?",
                options: ["skip_init", "skip_new", "skip_fpw", "skip_rep"],
                answer: 0
            }
        ];

        function createQuiz() {
            const container = document.getElementById('quiz-container');

            // Количество вопросов для отображения (можно изменить)
            const numQuestionsToShow = 10;

            // Создаем копию массива вопросов
            const shuffledQuestions = [...quizData];

            // Перемешиваем вопросы случайным образом
            for (let i = shuffledQuestions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledQuestions[i], shuffledQuestions[j]] = [shuffledQuestions[j], shuffledQuestions[i]];
            }

            // Выбираем нужное количество вопросов (или все, если их меньше)
            const selectedQuestions = shuffledQuestions.slice(0, Math.min(numQuestionsToShow, shuffledQuestions.length));

            // Сохраняем выбранные вопросы для проверки ответов
            window.selectedQuizData = selectedQuestions;

            // Отображаем выбранные вопросы
            selectedQuestions.forEach((item, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = "bg-gray-800 p-6 rounded-lg";
                questionDiv.innerHTML = `
                <h2 class="text-xl font-semibold mb-4">${index + 1}. ${item.question}</h2>
                <div class="space-y-2">
                    ${item.options.map((option, i) => `
                        <label class="flex items-center space-x-3 p-2 rounded-md hover:bg-gray-700 answer-label">
                            <input type="radio" name="q${index}" value="${i}" class="w-4 h-4 text-primary focus:ring-primary">
                            <span>${option}</span>
                        </label>
                    `).join('')}
                </div>
            `;
                container.appendChild(questionDiv);
            });
        }

        function checkAnswers() {
            let correct = 0;
            let hasUnanswered = false;
            const resultDiv = document.getElementById('result');
            const percentage = document.getElementById('percentage');

            // Получаем выбранные вопросы из глобальной переменной
            const selectedQuestions = window.selectedQuizData || [];

            document.querySelectorAll('.answer-label').forEach(label => {
                label.classList.remove('bg-green-900/20', 'bg-red-900/20', 'border', 'border-success', 'border-danger');
            });

            for (let i = 0; i < selectedQuestions.length; i++) {
                if (!document.querySelector(`input[name="q${i}"]:checked`)) {
                    hasUnanswered = true;
                    break;
                }
            }

            if (hasUnanswered) {
                alert('Пожалуйста, ответьте на все вопросы!');
                return;
            }

            selectedQuestions.forEach((item, index) => {
                const selected = document.querySelector(`input[name="q${index}"]:checked`);
                if (selected) {
                    const selectedLabel = selected.closest('.answer-label');
                    const correctLabel = document.querySelector(`input[name="q${index}"][value="${item.answer}"]`).closest('.answer-label');
                    if (parseInt(selected.value) === item.answer) {
                        correctLabel.classList.add('bg-green-900/20', 'border', 'border-success');
                        correct++;
                    } else {
                        selectedLabel.classList.add('bg-red-900/20', 'border', 'border-danger');
                        correctLabel.classList.add('bg-green-900/20', 'border', 'border-success');
                    }
                }
            });

            const percent = (correct / selectedQuestions.length) * 100;
            percentage.textContent = `${percent.toFixed(1)}%`;
            resultDiv.classList.remove('hidden');
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }

        window.onload = createQuiz;
    </script>

    {{template "footer.html" .}}
</body>

</html>